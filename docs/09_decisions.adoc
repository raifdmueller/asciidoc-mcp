== 9. Architecture Decisions

This chapter records the most important architectural decisions.

=== ADR-001: File-System as Single Source of Truth

[cols="1,3"]
|===
| Status | Accepted
| Date | 2025-09-18
| Decision Makers | Gemini Architect
|===

==== Context
The PRD requires that the system integrates with existing Git workflows, that files remain human-readable, and that there are no database dependencies. We need a simple, robust way to store the documentation content that honors these constraints.

==== Decision
The file system will be treated as the single source of truth. The server will not have its own persistent state. All content and structure information is derived directly from the `.adoc` and `.md` files within the project directory.

==== Consequences
*   **Pro**: Simplifies the architecture immensely. No database schema migrations or data synchronization logic needed.
*   **Pro**: Inherently compatible with Git and other version control systems.
*   **Pro**: Developers can still use their favorite text editors.
*   **Con**: Queries that are not based on the document's natural hierarchy may be inefficient to answer.
*   **Con**: The system's performance is tied to file system performance.

==== Alternatives Considered
*   **SQLite Database**: Store content in a local SQLite file. Rejected because it violates the "human-readable files" and "no database" constraints.
*   **Key-Value Store (e.g., RocksDB)**: Use an embedded database. Rejected for the same reasons as SQLite.

=== ADR-002: In-Memory Index for Performance

[cols="1,3"]
|===
| Status | Accepted
| Date | 2025-09-18
| Decision Makers | Gemini Architect
|===

==== Context
The quality goal PERF-1 requires API calls to respond in under 2 seconds. Reading and parsing text files from disk on every request would be too slow for large projects, as identified in the runtime analysis.

==== Decision
On startup, the server will perform a one-time scan of the entire project directory. It will parse all documentation files and build an "In-Memory Structure Index". This index will hold metadata about each document, including section names, hierarchical paths, and the start/end line numbers for each section in its source file. Read requests will consult this index to find the exact byte range to read from a file.

==== Consequences
*   **Pro**: Read operations (`get_section`) are extremely fast, as they become simple dictionary lookups followed by a targeted file read.
*   **Pro**: Enables efficient implementation of structure-aware APIs like `get_structure`.
*   **Con**: Increased memory consumption, proportional to the size of the documentation project.
*   **Con**: Slower server startup time due to the initial indexing phase.
*   **Con**: A mechanism to detect external file changes (file watching) is needed to keep the index from becoming stale.

==== Alternatives Considered
*   **No Index**: Parse the relevant files on every API request. Rejected due to poor performance that would violate quality goals.
*   **Persistent Disk-Based Index**: Cache the index to disk. Rejected as it adds complexity (cache invalidation) and violates the "stateless" principle from the solution strategy.

=== ADR-003: Technology Stack (Python/FastAPI)

[cols="1,3"]
|===
| Status | Accepted
| Date | 2025-09-18
| Decision Makers | Gemini Architect
|===

==== Context
A programming language and web framework are needed to build the MCP API Server. The choice must align with the need for rapid development, strong text-processing capabilities, and high performance for an I/O-bound application.

==== Decision
The backend will be implemented in **Python**. The **FastAPI** framework will be used to build the web server and API endpoints.

==== Consequences
*   **Pro**: Python has an exceptional ecosystem for text processing and data manipulation.
*   **Pro**: FastAPI provides high performance for I/O-bound tasks, data validation, and automatic OpenAPI/Swagger documentation, which helps achieve USAB-1 and USAB-2.
*   **Pro**: The large talent pool for Python simplifies maintenance.
*   **Con**: Python's GIL can be a limitation for CPU-bound tasks, but this application is primarily I/O-bound (reading files, network requests).

==== Alternatives Considered
*   **Node.js/Express**: A strong contender, also asynchronous and fast. Python was chosen for its perceived stronger data science and text-processing ecosystem.
*   **Go/Gin**: Offers superior raw performance and concurrency. Rejected because development time is typically longer, and the performance gain was not deemed critical enough to justify the trade-off.
*   **Java/Spring**: Mature and robust, but generally more verbose and memory-intensive, which was deemed overkill for this service.

=== ADR-004: Atomic Writes via Temporary Files

[cols="1,3"]
|===
| Status | Accepted
| Date | 2025-09-18
| Decision Makers | Gemini Architect
|===

==== Context
The quality goal REL-1 (Atomic Writes) is critical to prevent file corruption during `update` operations. A failure (e.g., disk full, application crash) during a file write could leave a document in an unrecoverable, partially-written state.

==== Decision
The `File System Handler` component will implement atomic writes using a backup-and-replace strategy:
1. Create a backup of the original file (e.g., `doc.adoc` -> `doc.adoc.bak`).
2. Write all intended changes to a new temporary file (e.g., `doc.adoc.tmp`).
3. If the write is successful, atomically rename/move the temporary file to replace the original file.
4. Delete the backup file.
5. If any step fails, restore the original file from the backup and delete the temporary file.

==== Consequences
*   **Pro**: Guarantees that the primary file is never in a corrupted state.
*   **Pro**: Relatively simple to implement and understand.
*   **Con**: Slightly higher I/O overhead for each write operation (copy, write, move). This is an acceptable trade-off for the gain in reliability.

==== Alternatives Considered
*   **Journaling**: Implement a file-based journal to log changes before applying them. Rejected as this is significantly more complex to implement correctly.
*   **In-place updates with locking**: Lock the file and update it directly. Rejected because it does not protect against application crashes or system power loss during the write.

=== ADR-005: Custom Parser for Include Resolution

[cols="1,3"]
|===
| Status | Accepted
| Date | 2025-09-18
| Decision Makers | Gemini Architect
|===

==== Context
A core feature is the ability to map a hierarchical path (e.g., `chapter-1.section-2`) to a precise location in a source file. This is complicated by AsciiDoc's `include::[]` directive, as content from multiple files is logically part of one document. Existing parsers often flatten the document, losing this critical source-map information.

==== Decision
A custom document parser will be developed. This parser will be responsible for:
1. Parsing the AsciiDoc/Markdown syntax.
2. Recognizing and recursively resolving `include::[]` directives.
3. Building an Abstract Syntax Tree (AST) that retains the original file path and line numbers for every single element of the document.

==== Consequences
*   **Pro**: Provides full control over the parsing process, ensuring the crucial source-map information is preserved.
*   **Pro**: Allows for tailored error handling of malformed documents or circular includes.
*   **Con**: Significant development and maintenance effort compared to using an off-the-shelf library. This is the most complex component of the system.

==== Alternatives Considered
*   **Use an existing library (e.g., `asciidoctor.py`)**: This was investigated, but most libraries are designed to render documents (e.g., to HTML), not to provide a detailed source map across included files. Adapting them was deemed more complex than building a focused, custom solution.
